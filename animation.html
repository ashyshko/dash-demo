<html>
<head>
<style>
    #overlay h1 {
        text-align: center;
    }

    #overlay li {
        font-size: 24px;
        line-height: 150%;
    }

</style>
</head>
<body onload="init()">
<script>
    const WIDTH = 1600
    const HEIGHT = 800

    const SCREEN_ASPECT_RATIO_EXTERNAL = 1.17162

    const SCREEN_INTERNAL_RECT = {
        x: (1-0.925)/2,
        y: 0.0388*2.8,
        w: 0.925,
        h: 0.7142*0.85,
    }

    const leftScreen = {
        x: 0,
        y: (HEIGHT - WIDTH / (SCREEN_ASPECT_RATIO_EXTERNAL * 6)) / 2 + 100,
        w: WIDTH / 6,
        h: WIDTH / (SCREEN_ASPECT_RATIO_EXTERNAL * 6),
    }

    const rightScreen = {
        ...leftScreen,
        x: WIDTH-leftScreen.w
    }

    const SCREEN_BASE_Y = leftScreen.y + leftScreen.h

    const screen = new Image()
    screen.src = "display.svg"

    const colorBars = new Image()
    colorBars.src = "colorBars.svg"

    const gear = new Image()
    gear.src = "gear.svg"

    const truck = new Image()
    truck.src = "truck.svg"

    const vimeo = new Image()
    vimeo.src = "vimeo.svg"

    const stop = new Image()
    stop.src = "stop.svg"

    const windSign = new Image()
    windSign.src = "wind_sign.svg"

    function drawContent(ctx, params) {
        ctx.save()
        ctx.lineWidth = 1
        ctx.fillStyle = params.alert ? "red" : "black"
        ctx.fillRect( params.x, params.y, params.w, params.h )

        if( params.id === undefined ) {
            ctx.drawImage( colorBars, params.x, params.y, params.w, params.h )
        } else {
            ctx.font = "1px serif"
            const fontSize = params.w / Math.max( ctx.measureText("888").width, ctx.measureText(params.id).width )
            ctx.font = `${fontSize}px serif`
            const measure = ctx.measureText(params.id)
            ctx.fillStyle = "white"
            ctx.fillText(params.id,
                params.x + (params.w - measure.width) / 2,
                params.y + (params.h - (measure.fontBoundingBoxAscent + measure.fontBoundingBoxDescent)) / 2 + measure.fontBoundingBoxAscent)
        }

        ctx.strokeStyle = "white"
        ctx.beginPath()
        ctx.rect( params.x, params.y, params.w, params.h )
        ctx.stroke()
        ctx.restore()
    }

    function drawContentRotated(ctx, params) {
        const cx = params.cx
        const cy = params.cy
        const angle = params.angle
        const id = params.id
        const w = params.w
        const h = params.h
        const alert = params.alert

        ctx.save()

        ctx.translate(params.cx, params.cy)
        ctx.rotate(params.angle)
        drawContent(ctx, {
            id,
            x: -w/2,
            y: -h/2,
            w,
            h,
            alert
        })

        ctx.restore()
    }

    function drawScreen(ctx, params) {
        ctx.drawImage(screen, params.x, params.y, params.w, params.h)

        drawContent(ctx, {
            x: params.x + params.w * SCREEN_INTERNAL_RECT.x,
            y: params.y + params.h * SCREEN_INTERNAL_RECT.y,
            w: params.w * SCREEN_INTERNAL_RECT.w,
            h: params.h * SCREEN_INTERNAL_RECT.h,
            id: params.id,
            alert: params.alert
        })
    }

    function drawBelt(ctx, params, drawCtx) {
        const startX = params.startX
        const endX = params.endX
        let y = params.y
        const speed = params.speed
        const active = params.active
        
        const BELT_RADIUS = 30
        const DASH_SIZE = 40
        const DASH_SPACE = 10
        const SPACE_Y = 5

        y += SPACE_Y

        drawCtx.startTime = drawCtx.startTime || Date.now()

        if( !active && drawCtx.lastTime !== undefined ) {
            drawCtx.startTime += (Date.now() - drawCtx.lastTime);
        }

        drawCtx.lastTime = Date.now()

        const delta = (DASH_SIZE + DASH_SPACE) - (((Date.now() - drawCtx.startTime) * speed / 1000) % (DASH_SIZE + DASH_SPACE))

        ctx.save()

        if( delta < DASH_SIZE ) {
            ctx.setLineDash([DASH_SIZE - delta, DASH_SPACE, delta, 0])
        } else {
            ctx.setLineDash([0, DASH_SPACE - (delta-DASH_SIZE), DASH_SIZE, (delta-DASH_SIZE)])
        }

        const gearCount = Math.trunc((endX - startX) / (2*BELT_RADIUS))
        const gearStep = gearCount > 1 ? (endX - startX - 2*BELT_RADIUS) / (gearCount-1) : 0;

        const GEAR_SIZE_MULTIPLIER = 0.85

        for( let i = 0; i < gearCount; ++i ) {
            ctx.save()
            ctx.translate(startX + i*gearStep + BELT_RADIUS, y+BELT_RADIUS);
            ctx.rotate(delta * 2 * Math.PI / (DASH_SIZE + DASH_SPACE));
            ctx.drawImage(
                gear,
                -BELT_RADIUS * GEAR_SIZE_MULTIPLIER,
                -BELT_RADIUS * GEAR_SIZE_MULTIPLIER,
                2*BELT_RADIUS*GEAR_SIZE_MULTIPLIER,
                2*BELT_RADIUS*GEAR_SIZE_MULTIPLIER );
            ctx.restore()
        }
        

        ctx.strokeStyle = "black"
        ctx.lineWidth = 4

        ctx.beginPath()
        ctx.arc( startX + BELT_RADIUS, y + BELT_RADIUS, BELT_RADIUS, 0.5 * Math.PI, 1.5 * Math.PI )
        ctx.moveTo( startX + BELT_RADIUS, y )
        ctx.lineTo( endX - BELT_RADIUS, y )
        ctx.arc( endX - BELT_RADIUS, y + BELT_RADIUS, BELT_RADIUS, 1.5 * Math.PI, 0.5 * Math.PI )
        ctx.moveTo( endX - BELT_RADIUS, y + 2 * BELT_RADIUS )
        ctx.lineTo( startX + BELT_RADIUS, y + 2 * BELT_RADIUS )
        ctx.stroke()

        ctx.restore()
    }

    function drawCatapult(ctx, params) {
        const cx = params.cx
        const cy = params.cy
        const lw = params.lw
        const angle = params.angle

        ctx.save()

        ctx.translate(cx, cy)
        ctx.scale(lw / 480, lw / 480)
        ctx.translate(-650, -630)

        ctx.strokeStyle = "white"
        ctx.fillStyle = "black"

        ctx.lineWidth = 10


        {
            ctx.save()
            ctx.translate(490, 680)
            ctx.rotate(230/180 * Math.PI)
            ctx.beginPath()
            ctx.rect( -15, -15, 30, 320 );
            ctx.stroke()
            ctx.fill()
            ctx.restore()
        }

        {
            ctx.save()

            ctx.translate(690, 680)
            ctx.rotate(angle)
            ctx.beginPath()
            ctx.rect( -20, -20, -500, 40 );
            ctx.stroke()
            ctx.fill()

            ctx.beginPath()
            ctx.arc( -520, -40, 80, 0, Math.PI )
            ctx.fill()
            ctx.stroke()

            ctx.restore()
        }

        ctx.beginPath()
        ctx.rect( 700, 340, 780-700, 650-340 );
        ctx.fill()
        ctx.stroke()

        ctx.beginPath()
        ctx.rect( 280, 640, 810-280, 720-640 );
        ctx.fill()
        ctx.stroke()

        ctx.beginPath()
        ctx.arc( 740, 720, 45, 0, 2 * Math.PI );
        ctx.fill()
        ctx.stroke()

        ctx.beginPath()
        ctx.arc( 350, 720, 45, 0, 2 * Math.PI );
        ctx.fill()
        ctx.stroke()

        ctx.restore()
    }

    const TRUCK_ASPECT = 1.8916

    function drawTruck(ctx, params) {
        const { x, y, w, h, id, alert, mirror } = params

        const BODY = {
            x: 0.1114,
            y: 0.2965,
            w: 0.7772,
            h: 0.4108 
        }

        const SCREEN = {
            x: 0.2971,
            y: 0,
            w: 0.7009,
            h: 0.6842
        }

        const SCREEN_SIZE_NORMALIZED = {
            w: WIDTH / 10,
            h: (WIDTH / 10) / 1.938
        }


        ctx.save()

        ctx.translate( x + w/2, y + h/2 )
        ctx.scale( mirror ? w : -w, h )

        ctx.drawImage(truck, -0.5 - BODY.x / BODY.w, -0.5 - BODY.y / BODY.h, 1 / BODY.w, 1 / BODY.h)

        ctx.translate( SCREEN.x - 0.5 + SCREEN.w / 2, SCREEN.y - 0.5 + SCREEN.h / 2 )
        ctx.scale( SCREEN.w * (!mirror ? -1 : 1) / SCREEN_SIZE_NORMALIZED.w, SCREEN.h / SCREEN_SIZE_NORMALIZED.h )

        // ctx.fillStyle = "rgba(0,255,0,0.5)"
        // ctx.fillRect(-SCREEN_SIZE_NORMALIZED.w / 2, -SCREEN_SIZE_NORMALIZED.h / 2, SCREEN_SIZE_NORMALIZED.w, SCREEN_SIZE_NORMALIZED.h)

        if( id !== undefined ) {
            drawContent(ctx, {
                x: -SCREEN_SIZE_NORMALIZED.w / 2,
                y: -SCREEN_SIZE_NORMALIZED.h / 2,
                w: SCREEN_SIZE_NORMALIZED.w,
                h: SCREEN_SIZE_NORMALIZED.h,
                id,
                alert
            })
        } else {
            // vimeo icon is square
            const MULT = 0.7
            ctx.drawImage(vimeo, -SCREEN_SIZE_NORMALIZED.h / 2 * MULT, -SCREEN_SIZE_NORMALIZED.h / 2 * MULT, SCREEN_SIZE_NORMALIZED.h * MULT, SCREEN_SIZE_NORMALIZED.h * MULT)
        }

        ctx.restore()

    }

    class ImageSequence {
        // ffmpeg -i file.gif -vsync 0 prefix_%d.png
        constructor(params) {
            const prefix = params.prefix
            const count = params.count
            const ext = params.ext || "png"
            this.aspect = params.aspect

            this.images = []
            for( let i = 1; i <= count; ++i ) {
                const img = new Image()
                img.src = `${prefix}${i}.${ext}`
                this.images.push(img)
            }
        }

        start(fps) {
            const obj = {
                lastUpdate: Date.now(),
                aspect: this.aspect,
                index: 0,
                fps
            }

            obj.update = () => {
                const now = Date.now()

                if(obj.fps) {
                    obj.index += (now - obj.lastUpdate) * obj.fps / 1000
                }

                while(obj.index < 0) {
                    obj.index += this.images.length
                }

                obj.index = obj.index % this.images.length
                obj.lastUpdate = now
            }

            obj.draw = (ctx, params) => {
                obj.update()

                ctx.drawImage( this.images[Math.trunc(obj.index)], params.x, params.y, params.w, params.h )
            }

            return obj;
        }
    }

    const bird1 = new ImageSequence({
        prefix: "bird1/bird_",
        count: 26,
        extension: "png",
        aspect: 198/189 })


    class Intro {
        constructor(ids) {
            this.ids = ids
        }

        next() {
        }

        draw(ctx) {
            drawScreen(ctx, {...leftScreen, id: this.ids?.[0]})
            drawScreen(ctx, {...rightScreen, id: this.ids?.[1]})
        }
    }

    class ItemQueue {
        constructor(params) {
            this.itemSize = {
              w: params.itemSize.w,
              h: params.itemSize.h
            }
            this.startX = params.startX
            this.endX = params.endX
            this.baseY = params.baseY
            this.minSpaceX = params.minSpaceX

            this.items = []
        }

        onItemFinished = (id) => undefined;

        addItem(id) {
            if( this.items.length !== 0 && this.items[this.items.length-1].x < this.startX + this.items[this.items.length-1].w + this.minSpaceX ) {
                return false;
            }
    
            this.items.push({
                id,
                x: this.startX,
                y: this.baseY - this.itemSize.h,
                w: this.itemSize.w,
                h: this.itemSize.h,
                stuck: false,
                blocked: false
            })

            return true;
        }

        start(speed) {
            this.speed = speed
        }

        stop() {
            this.speed = 0
        }

        progress() {
            const now = Date.now()

            if( this.lastUpdate === undefined ) {
                this.lastUpdate = now
                return
            }

            const moveX = this.speed * (now - this.lastUpdate) / 1000
            this.lastUpdate = now
            
            for( let i = 0; i < this.items.length; ) {
                const item = this.items[i]
                const prevItem = this.items[i-1] // may be undefined

                if(item.blocked) {
                    item.stuck = true;
                    ++i;
                    continue;
                }

                if( prevItem && prevItem.x <= item.x + moveX + item.w + this.minSpaceX ) {
                    item.stuck = prevItem.stuck;
                    item.x = prevItem.x - (item.w + this.minSpaceX)
                    ++i;
                } else {
                    item.stuck = false;
                    item.x += moveX
                    if( item.x + item.w >= this.endX ) {
                        this.onItemFinished(item.id)
                        this.items.shift()
                    } else {
                        ++i;
                    }
                }
            }
        }
    }

    const BELT_BOX_SIZE = {
        w: WIDTH / 10,
        h: (WIDTH / 10) * (9/16)
    }

    const BELT_SPEED = ( rightScreen.x - (leftScreen.x + leftScreen.w) ) / 3

    class BeltAnimation {
        constructor() {
            this.queue = new ItemQueue({
                itemSize: BELT_BOX_SIZE,
                startX: leftScreen.x+leftScreen.w,
                endX: rightScreen.x,
                baseY: SCREEN_BASE_Y,
                minSpaceX: 2
            })
        }

        next() {
            if(this.startTime === undefined) {
                this.startTime = Date.now()
                this.leftId = -1
                this.rightId = -1
                this.queue.start(BELT_SPEED)
                this.queue.onItemFinished = (id) => {
                    this.rightId = id
                    if( this.rightStartTime === undefined ) {
                        this.rightStartTime = Date.now() - id * 1000
                    }
                }
            }
            else if( this.queue.items.length > 0 ) {
                this.queue.items[0].blocked = !this.queue.items[0].blocked;
            }
        }

        draw(ctx) {
            const leftScreenData = {...leftScreen}
            const rightScreenData = {...rightScreen}

            if( this.startTime !== undefined ) {
                if( Date.now() > this.startTime + (this.leftId+1) * 1000 ) {
                    this.leftId++;
                    this.beltStuck = !this.queue.addItem(this.leftId)
                }

                leftScreenData.id = this.leftId
                rightScreenData.id = this.rightId >= 0 ? this.rightId : undefined

                if( this.rightStartTime !== undefined ) {
                    if( Date.now() > this.rightStartTime + (this.rightId + 1) * 1000 + 3000 ) {
                        rightScreenData.id = undefined;
                    } else if( Date.now() > this.rightStartTime + (this.rightId + 1) * 1000 + 100 /*100ms reserve*/ ) {
                        rightScreenData.alert = true;
                    }
                }
            }

            this.queue.progress()

            this.beltDrawCtx = this.beltDrawCtx || {}
            drawBelt(ctx, {
                startX: leftScreen.x+leftScreen.w,
                endX: rightScreen.x,
                y: SCREEN_BASE_Y,
                speed: BELT_SPEED,
                active: !this.beltStuck && this.startTime !== undefined
            }, this.beltDrawCtx)

            drawScreen(ctx, leftScreenData)
            drawScreen(ctx, rightScreenData)

            for( const item of this.queue.items ) {
                drawContent(ctx, {...item, alert: item.stuck})
            }
        }
    }

    const CATAPULT_BOX_SIZE = BELT_BOX_SIZE
    const CATAPULT_TARGET_DELIVERY_TIME = 1
    const CATAPULT_WIND_SPEED_INITIAL = (rightScreen.x - (leftScreen.x + leftScreen.w)) * 0.3 / CATAPULT_TARGET_DELIVERY_TIME
    const CATAPULT_WIND_SPEED_DELTA = CATAPULT_WIND_SPEED_INITIAL

    const CATAPULT_BIRD_H = HEIGHT / 8
    const CATAPULT_BIRD_Y = {
        min: 0,
        max: CATAPULT_BIRD_H + HEIGHT / 4
    }
    const CATAPULT_BIRD_SPEED = WIDTH / 1.5


    class CatapultAnimation {
        constructor() {
            this.items = []
        }
        
        next() {
            if( this.startTime === undefined ) {
                this.startTime = Date.now();
                this.leftId = -1
            }
            else if( this.windSpeed === undefined && this.allowBird === undefined ) {
                this.windSpeed = CATAPULT_WIND_SPEED_INITIAL
                this.lastWindChange = Date.now()
            } else if( this.allowBird === undefined ) {
                this.windSpeed = undefined
                this.allowBird = true;
            } else {
                this.windSpeed = undefined
                this.allowBird = undefined
            }
        }

        draw(ctx) {
            const now = Date.now()

            const leftScreenData = {...leftScreen}
            const rightScreenData = {...rightScreen}

            if( this.windSpeed !== undefined ) {
                ctx.drawImage( windSign, WIDTH * 9/10 - 10, 10, WIDTH / 10, WIDTH * (280/320) / 10  )
            }

            if( this.startTime !== undefined && now >= this.startTime + this.leftId * 1000 ) {
                this.leftId++;

                const maxY = SCREEN_BASE_Y - 2 * CATAPULT_BOX_SIZE.h
                const g = 2 * maxY / (CATAPULT_TARGET_DELIVERY_TIME * CATAPULT_TARGET_DELIVERY_TIME / 4)

                const sx = (rightScreen.x - (leftScreen.x+leftScreen.w) - CATAPULT_BOX_SIZE.w) / CATAPULT_TARGET_DELIVERY_TIME
                const sy = -g * CATAPULT_TARGET_DELIVERY_TIME / 2

                const angleSpeed = Math.PI * 2

                this.items.push({
                    id: this.leftId,
                    x: leftScreen.x+leftScreen.w + CATAPULT_BOX_SIZE.w/2,
                    y: SCREEN_BASE_Y - CATAPULT_BOX_SIZE.h/2,
                    angle: 0,
                    sx,
                    sy,
                    g,
                    angleSpeed,
                    missed: false,
                    lastUpdate: now
                })

                this.catapultCtx = this.ctapultCtx || {}
                this.catapultCtx.angle = 0
                this.catapultCtx.speed = angleSpeed
                this.catapultCtx.lastUpdate = now
            }

            if( this.windSpeed !== undefined ) {
                this.windSpeed += (Math.random() * 2 - 1) * CATAPULT_WIND_SPEED_DELTA * (now - this.lastWindChange) / 1000
                if( this.windSpeed < 0 ) {
                    this.windSpeed = 0
                }
                this.lastWindChange = now
            }

            if( this.noBird ) {
                this.noBird.timeout -= (now - this.noBird.lastUpdate) / 1000
                this.noBird.lastUpdate = now

                if( this.noBird.timeout <= 0 ) {
                    this.noBird = undefined
                }
            } else if( !this.bird && this.allowBird ) {
                const obj = bird1;

                const size = {
                    w: CATAPULT_BIRD_H * obj.aspect,
                    h: CATAPULT_BIRD_H,
                }

                this.bird = {
                    obj: bird1.start(15),
                    ...size,
                    x: WIDTH - size.w,
                    y: CATAPULT_BIRD_Y.min + Math.random() * (CATAPULT_BIRD_Y.max - CATAPULT_BIRD_Y.min - size.h),
                    lastUpdate: now
                }
            }

            if( this.bird ) {
                if( this.bird.blockFor >= 0 ) {
                    this.bird.blockFor -= (now - this.bird.lastUpdate ) / 1000
                    this.bird.lastUpdate = now
                    
                    if( this.bird.blockFor < 0 ) {
                        this.bird = undefined
                        this.noBird = {
                            timeout: 1 + Math.random() * 0.5,
                            lastUpdate: now
                        }
                    }
                } else {
                    this.bird.x -= CATAPULT_BIRD_SPEED * (now - this.bird.lastUpdate ) / 1000
                    this.bird.lastUpdate = now
                    
                    if( this.bird.x < 0 ) {
                        this.bird = undefined
                        this.noBird = {
                            timeout: 1 + Math.random() * 0.5,
                            lastUpdate: now
                        }
                    }
                }
            }

            for( let i = 0; i < this.items.length; ) {
                const item = this.items[i]

                if(item.blockFor >= 0) {
                    item.blockFor -= (now - item.lastUpdate) / 1000
                    item.lastUpdate = now

                    if( item.blockFor >= 0 ) {
                        ++i
                    } else {
                        this.items.splice(i, 1)
                    }

                } else {
                    const t = (now - item.lastUpdate) / 1000
                    item.x = item.x + (item.sx - (this.windSpeed||0)) * t;
                    item.y = item.y + item.sy * t + item.g * t * t / 2
                    item.sy = item.sy + item.g * t
                    item.angle += item.angleSpeed * t
                    item.lastUpdate = now

                    if(this.bird) {
                        const bird = {
                            cx: this.bird.x + this.bird.w / 2,
                            cy: this.bird.y + this.bird.h / 2,
                            r: Math.min(this.bird.w, this.bird.h)
                        }

                        const r = Math.min(CATAPULT_BOX_SIZE.w, CATAPULT_BOX_SIZE.h)

                        const dist2 = (item.x - bird.cx) * (item.x - bird.cx) + (item.y - bird.cy) * (item.y - bird.cy)
                        const r2 =  r * r

                        if( dist2 <= r2 ) {
                            if( this.bird.blockFor === undefined ) {
                                this.bird.blockFor = 0.5
                                this.bird.obj.fps = 60
                            }
                            item.missed = true
                            item.blinking = true
                            item.blockFor = 0.5
                        }
                    }

                }


                if( item.y > SCREEN_BASE_Y - CATAPULT_BOX_SIZE.h / 2 ) {
                    if( !item.missed && item.x >= rightScreen.x - CATAPULT_BOX_SIZE.w * 1.5 ) {
                        this.rightId = item.id

                        if( this.rightStartTime === undefined ) {
                            this.rightStartTime = Date.now() - item.id * 1000
                        }
                    } else {
                        item.missed = true;
                    }
                    
                    if( item.x >= rightScreen.x - CATAPULT_BOX_SIZE.w || !item.missed ) {
                        this.items.shift()
                        continue
                    }
                }

                if( !item.blinking || (now/1000) % 0.1 < 0.05) {
                    drawContentRotated(ctx, {...item,
                       cx: item.x,
                       cy: item.y,
                       angle: item.angle,
                       w: CATAPULT_BOX_SIZE.w,
                       h: CATAPULT_BOX_SIZE.h,
                       alert: item.missed })
               }
                ++i
            }

            this.beltDrawCtx = this.beltDrawCtx || {}
            drawBelt(ctx, {
                startX: rightScreen.x - CATAPULT_BOX_SIZE.w,
                endX: rightScreen.x,
                y: SCREEN_BASE_Y,
                speed: 0,
                active: false
            }, this.beltDrawCtx )

            if( this.leftId >= 0 ) {
                leftScreenData.id = this.leftId
            }

            if( this.rightId >= 0 ) {
                rightScreenData.id = this.rightId

                if( this.rightStartTime !== undefined ) {
                    if( Date.now() > this.rightStartTime + this.rightId * 1000 + 3000 ) {
                        rightScreenData.id = undefined
                    } else if( Date.now() > this.rightStartTime + this.rightId * 1000 + 100 /*100ms reserve*/ ) {
                        rightScreenData.alert = true;
                    }
                }

            }
    
            drawScreen(ctx, leftScreenData)
            drawScreen(ctx, rightScreenData)

            if(this.catapultCtx) {
                this.catapultCtx.angle += this.catapultCtx.speed * (now - this.catapultCtx.lastUpdate) / 1000
                this.catapultCtx.lastUpdate = now

                if(this.catapultCtx.speed > 0 && this.catapultCtx.angle >= Math.PI / 4 ) {
                    this.catapultCtx.angle = Math.PI / 4
                    this.catapultCtx.speed = -this.catapultCtx.speed
                } else if( this.catapultCtx.speed < 0 && this.catapultCtx.angle <= 0 ) {
                    this.catapultCtx.angle = 0
                    this.catapultCtx.speed = 0
                }
            }

            drawCatapult(ctx, {
                cx: leftScreen.x + leftScreen.w + CATAPULT_BOX_SIZE.w * 5/4,
                cy: SCREEN_BASE_Y,
                lw: CATAPULT_BOX_SIZE.w * 3/4,
                angle: this.catapultCtx?.angle || 0
            });

            if( this.bird ) {
                this.bird.obj.draw(ctx, {
                    ...this.bird,
                    obj: undefined,
                })
            }
            
        }
    }

    const CARGO_BOX_SIZE = BELT_BOX_SIZE
    const CARGO_LANE_COUNT = 4

    const CARGO_TRUCK_SIZE = {
        h: CARGO_BOX_SIZE.h,
        w: CARGO_BOX_SIZE.h * TRUCK_ASPECT };

    const CARGO_LANE_OFFSET = HEIGHT / 20

    const CARGO_TRUCK_SPEED = WIDTH / 3


    const CARGO_STACK_OFFSET = 5
    const CARGO_STACK_BORDER = 2
    const CARGO_STACK_MIN_ITEMS = 4

    const CARGO_STOP_SIGN_SIZE = HEIGHT / 15

    const CARGO_STACK_W = CARGO_BOX_SIZE.w + 2 * CARGO_STACK_OFFSET + 4 * CARGO_STACK_BORDER

    class Stack {
        constructor(x) {
            this.x = x
            this.items = []
        }

        add(id, freezeFor) {
            this.items.push({id, freezeBefore: Date.now() + (freezeFor||0)*1000})
        }

        empty() {
            return this.getIndexToTake() === -1
        }

        getIndexToTake() {
            const now = Date.now()
            let minIndex = -1
            for( let i = 0; i < this.items.length; ++i ) {
                if( this.items[i].freezeBefore > now ) {
                    continue;
                }

                if( minIndex === -1 || this.items[i].id < this.items[minIndex].id ) {
                    minIndex = i
                }
            }

            return minIndex
        }

        get() {
            const minIndex = this.getIndexToTake()
            if( minIndex === -1 ) {
                return
            }

            return this.items[minIndex].id
        }

        take() {
            const minIndex = this.getIndexToTake()
            if( minIndex === -1 ) {
                return
            }

            const res = this.items[minIndex].id
            this.items.splice(minIndex, 1)
            return res
        }

        draw(ctx) {
            ctx.save()

            ctx.lineWidth = CARGO_STACK_BORDER
            ctx.strokeStyle = "black"

            ctx.beginPath()

            for( let i = 0; i < Math.max( CARGO_STACK_MIN_ITEMS, this.items.length ); ++i ) {
                const x = this.x + CARGO_STACK_OFFSET + CARGO_STACK_BORDER/2
                const y = SCREEN_BASE_Y - i * (4*CARGO_STACK_BORDER+CARGO_BOX_SIZE.h) - (2 * CARGO_STACK_BORDER+CARGO_BOX_SIZE.h) - CARGO_STACK_BORDER/2
                const w = CARGO_STACK_BORDER * 3 + CARGO_BOX_SIZE.w
                const h = CARGO_STACK_BORDER * 2 + CARGO_BOX_SIZE.h

                ctx.moveTo( x, y )
                ctx.lineTo( x, y + h )
                ctx.lineTo( x + w, y + h )
                ctx.lineTo( x + w, y )
            }

            ctx.stroke()

            ctx.restore()

            let y = SCREEN_BASE_Y - CARGO_BOX_SIZE.h - 2 * CARGO_STACK_BORDER

            for( const item of this.items ) {
                drawContent(ctx, {
                    id: item.id,
                    x: this.x + CARGO_STACK_OFFSET + 2 * CARGO_STACK_BORDER,
                    y,
                    w: CARGO_BOX_SIZE.w,
                    h: CARGO_BOX_SIZE.h
                })

                y -= CARGO_BOX_SIZE.h + 4 * CARGO_STACK_BORDER
            }
        }
    }

    class CargoExpressAnimation {
        constructor() {
            this.leftStack = new Stack(leftScreen.x+leftScreen.w)
            this.rightStack = new Stack(rightScreen.x - CARGO_STACK_W)
            this.lanes = []

            for( let i = 0; i < CARGO_LANE_COUNT; ++i ) {
                const lane = new ItemQueue( {
                    itemSize: CARGO_TRUCK_SIZE,
                    startX: leftScreen.x+leftScreen.w+CARGO_STACK_W,
                    endX: rightScreen.x - CARGO_STACK_W,
                    baseY: SCREEN_BASE_Y - i * (CARGO_TRUCK_SIZE.h+CARGO_LANE_OFFSET),
                    minSpaceX: 2
                });
                lane.onItemFinished = (id) => {
                    if( id !== undefined ) {
                        if( !lane.reverse ) {
                            this.rightStack.add(id)
                            if( this.rightStartTime === undefined ) {
                                this.rightStartTime = Date.now() - (id * 1000) + 3000
                            }
                            lane.reverse = true;
                            lane.addItem(undefined)
                        } else {
                            lane.reverse = false
                            this.leftStack.add(id, 0.5)
                        }
                    } else {
                        lane.reverse = false;
                    }
                }
                lane.start(CARGO_TRUCK_SPEED)
                this.lanes.push( lane )
            }
        }

        next() {
            if( this.startTime === undefined ) {
                this.startTime = Date.now();
                this.leftId = -1
                return this
            } else {
                for( const lane of this.lanes ) {
                    if( !lane.blocked ) {
                        lane.blocked = true

                        if( !lane.reverse ){
                            for( const item of lane.items ) {
                                item.x =  (lane.endX - CARGO_TRUCK_SIZE.w  - lane.startX) - (item.x - lane.startX) + lane.startX
                            }
                            lane.reverse = true;
                        }

                        return this
                    }
                }

                for( const lane of this.lanes ) {
                    lane.blocked = false;
                }
                return this
            }

        }

        draw(ctx) {
            const now = Date.now()

            const leftScreenData = {...leftScreen}
            const rightScreenData = {...rightScreen}

            if( this.startTime !== undefined && now >= this.startTime + (this.leftId+1) * 1000 ) {
                this.leftId++;
                this.leftStack.add(this.leftId, 0.5)
            }

            if(this.leftId !== undefined) {
                leftScreenData.id = this.leftId;
            }

            if( this.rightStartTime !== undefined ) {
                while( true ) {
                    const id = this.rightStack.get()
                    if( id === undefined ) {
                        break;
                    }

                    if( now < this.rightStartTime + id * 1000 ) {
                        break;
                    }

                    if( now > this.rightStartTime + id * 1000 + 500 ) {
                        this.rightStack.take()
                        continue;
                    }

                    this.rightId = id
                    this.rightStack.take()
                }
            }

            rightScreenData.id = this.rightId

            if( this.rightId !== undefined ) {
                if( now > this.rightStartTime + this.rightId * 1000 + 3000 ) {
                    rightScreenData.id = undefined
                } else if( now > this.rightStartTime + this.rightId * 1000 + 1100 ) {
                    rightScreenData.alert = true
                }
            }

            while( !this.leftStack.empty() ) {
                let laneIndex = -1
                this.nextTruckIndex = this.nextTruckIndex || 0
                for( let i = 0; i < this.lanes.length; ++i ) {
                    const index = (i + this.nextTruckIndex) % this.lanes.length
                    if( this.lanes[index].items.length === 0 && !this.lanes[index].blocked ) {
                        laneIndex = index;
                        break;
                    }
                }
                if( laneIndex < 0 ) {
                    break
                }

                this.lanes[laneIndex].addItem(this.leftStack.take())
                this.lanes[laneIndex].reverse = false;
                this.nextTruckIndex = laneIndex + 1
            }

            for( const lane of this.lanes ) {
                lane.progress()
            }


            this.leftStack.draw(ctx)
            this.rightStack.draw(ctx)

            for( const lane of this.lanes ) {

                {
                    ctx.save()
                    ctx.fillStyle = "#aaaaaa"
                    ctx.fillRect( lane.startX, lane.baseY, lane.endX - lane.startX, CARGO_LANE_OFFSET * 1/2 )
                    ctx.strokeStyle = "black"
                    ctx.lineWidth = 3
                    ctx.beginPath()
                    ctx.moveTo(lane.startX + 3 / 2, lane.baseY + 3 / 2)
                    ctx.lineTo(lane.endX - 3 / 2, lane.baseY + 3 / 2)
                    ctx.stroke()
                    ctx.restore()
                }

                if( lane.blocked ) {
                    ctx.drawImage( stop, lane.endX - CARGO_STOP_SIGN_SIZE, lane.baseY - (CARGO_TRUCK_SIZE.h - CARGO_STOP_SIGN_SIZE)/2 - CARGO_STOP_SIGN_SIZE, CARGO_STOP_SIGN_SIZE, CARGO_STOP_SIGN_SIZE )
                }

                if( lane.items.length > 0 ) {
                    for( const item of lane.items ) {
                        const params = {...item,
                            alert: item.stuck,
                            mirror: false };
                        if(lane.reverse) {
                            params.x = lane.endX - CARGO_TRUCK_SIZE.w + lane.startX - params.x
                            params.mirror = true;
                        }
                        drawTruck(ctx, params)
                    }
                } else if( !lane.blocked ) {
                    drawTruck(ctx, {
                        x: lane.startX,
                        y: lane.baseY - CARGO_TRUCK_SIZE.h,
                        w: CARGO_TRUCK_SIZE.w,
                        h: CARGO_TRUCK_SIZE.h,
                        id: undefined
                    })
                }
            }

            drawScreen(ctx, leftScreenData)
            drawScreen(ctx, rightScreenData)
        }
    }

    class IronTriangle {
        constructor() {
            this.step = 0
        }
        
        next() {
            this.step = (this.step + 1 ) % 4
        }

        draw(ctx) {
            ctx.save()

            ctx.translate( WIDTH / 2, SCREEN_BASE_Y );
            ctx.scale( (SCREEN_BASE_Y - HEIGHT / 10) / Math.sqrt(3), (SCREEN_BASE_Y - HEIGHT / 10) / Math.sqrt(3) )

            ctx.lineWidth = 64 / WIDTH

            const colors = ["#f79544", "#6fc2ee", "#904a81"]
            for( let i = 0; i < 3; ++i ) {
                ctx.save()
                ctx.translate(0, -Math.sqrt(3)/3)
                ctx.rotate( i * 2 * Math.PI / 3 )
                ctx.translate(0, Math.sqrt(3)/3)
                ctx.fillStyle = colors[i]
                ctx.strokeStyle = "white"
                ctx.beginPath()
                ctx.moveTo(1, 0)
                ctx.lineTo(0, 0)
                ctx.lineTo(0, -Math.sqrt(3)/3)
                ctx.lineTo(1/2, -Math.sqrt(3)/2)
                ctx.lineTo(1,0)
                ctx.fill()
                ctx.stroke()
                ctx.restore()
            }

            const drawText = (x,y,text) => {
                ctx.font = `${200 / WIDTH}px monospace`
                const m = ctx.measureText(text)
                //ctx.lineWidth = 16 / WIDTH
                ctx.fillStyle = "white"
                ctx.fillText( text, x - m.width / 2, y )
            }

            const drawBaloon = (x,y,text, color) => {
                ctx.font = `${350 / WIDTH}px monospace`
                const m = ctx.measureText(text)
                //ctx.lineWidth = 16 / WIDTH
                ctx.fillStyle = color
                ctx.beginPath()
                ctx.ellipse(x,y,0.4/*m.width/2 * 2*/,0.3 /*(m.fontBoundingBoxAscent + m.fontBoundingBoxDescent)/2 * 3*/,0,0,Math.PI * 3)
                ctx.fill()

                ctx.fillStyle = "white"
                ctx.fillText( text, x - m.width / 2, y + (m.fontBoundingBoxAscent - m.fontBoundingBoxDescent)/2 )
                
            }

            drawText( 0.4, -0.25, "Stability" )
            drawText( 0., -1.0, "Latency" )
            drawText( -0.4, -0.25, "Quality" )

            if(this.step >= 1 ) {
                drawBaloon( 0, -1.5, "SRT", "rgba(255,0,0,80%)")
            }

            if(this.step >= 2) {
                drawBaloon( 0, -0.75, "RTMP", "rgba(255,215,0,80%)")
            }

            if(this.step >= 3) {
                drawBaloon( 0, 0, "DASH", "rgba(0,127,0,80%)")
            }

            ctx.restore()

            drawScreen(ctx, leftScreen)
            drawScreen(ctx, rightScreen)
        }
    }

    let animation

    function animate() {
        if( !animation ) {
            return;
        }

        const canvas = document.getElementById("canvas")
        canvas.width = WIDTH
        canvas.height = HEIGHT
        const ctx = canvas.getContext("2d")

        ctx.fillStyle = "#eeeeee"
        ctx.fillRect( 0, 0, WIDTH, HEIGHT )

        animation.draw(ctx, ctx.width, ctx.height)

        requestAnimationFrame(animate)
    }
    
    const outroObj = {
        name: "Outro",
        create: () => new Intro,
        next: undefined,
        html: `
            <img src="bird1/bird.gif"></img>
        `
    }

    const benefitsObj = {
        name: "Benefits",
        create: () => new Intro(),
        next: outroObj,
        html: `
            <h1>Our Benefits</h1>
            <ul>
                <li>Simpler infrastructure</li>
                <li>Using Google HTTP LoadBalancer</li>
                <li>Full control of pipeline</li>
                <li>Distributed transcoder opportunity</li>
            </ul>
        `
    }

    const transmitterObj = {
        name: "Transmitter service",
        create: () => new Intro(),
        next: benefitsObj,
        html: `
            <h1>RTMP-to-DASH Transmitter Service</h1>
            <img width=${WIDTH / 3} src="14std.jpeg"></img>
        `
    }

    const ironTriangleObj = {
        name: "Iron Triangle",
        create: () => new IronTriangle,
        next: transmitterObj
    }

    const cargoObj = {
        name: "Live MPEG-DASH",
        create: () => new CargoExpressAnimation,
        next: ironTriangleObj 
    }

    const dashIntroObj = {
        name: "Live MPEG-DASH Intro",
        create: () => new Intro(["A", "B"]),
        next: cargoObj,
        html: `
            <h1>MPEG-DASH</h1>
            <ul>
                <li>Stream chunked to small HTTP requests</li>
                <li>High latency</li>
            </ul>

        `
    }

    const catapultObj = {
        name: "SRT/RIST/Zixi",
        create: () => new CatapultAnimation,
        next: dashIntroObj
    }

    const srtIntroObj = {
        name: "SRT/RIST/Zixi Intro",
        create: () => new Intro(["A", "B"]),
        next: catapultObj,
        html: `
            <h1>SRT/RIST/Zixi</h1>
            <ul>
                <li>Designer for Low Latency streaming</li>
                <li>UDP protocol + error correction</li>
            </ul>
        `
    }

    const beltObj = {
        name: "RTMP",
        create: () => new BeltAnimation,
        next: srtIntroObj
    }

    const rtmpIntroObj = {
        name: "RTMP Intro",
        create: () => new Intro(["A", "B"]),
        next: beltObj,
        html: `
            <h1>RTMP</h1>
            <ul>
                <li>Industry standard for live streaming</li>
                <li>Single TCP connection</li>
            </ul>
        `
    }

    const protocolsObj = {
        name: "Protocols",
        create: () => new Intro(["A", "B"]),
        next: rtmpIntroObj,
        html: `
            <h1>Live Video Delivery Protocols</h1>
            <ul>
                <li>RTMP</li>
                <li>SRT/RIST/Zixi</li>
                <li>MPEG-DASH</li>
            </ul>`
    }


    const introObj = {
        name: "Intro",
        create: () => new Intro(),
        next: protocolsObj,
        html: `
            <h1>Reliable Live</h1>
            <ul>
                <li>Support MPEG-DASH Protocol for Live Video Ingestion</li>
            </ul>`
    }

    let animationObj

    function onNextScene() {
        animation.next()
    }

    function onNextAnimation() {
        if( animationObj ) {
            animationObj = animationObj.next
        }

        if( !animationObj ) {
            animationObj = introObj
        }

        animation = animationObj.create()
        
        if( animationObj.next ) {
            document.getElementById("next_animation").innerHTML = `Next to ${animationObj.next.name}`
        } else {
            document.getElementById("next_animation").innerHTML = "Finish"
        }

        if(animationObj.html) {
            document.getElementById("overlay").innerHTML = animationObj.html;
            document.getElementById("overlay_container").style.display = "flex"
        } else {
            document.getElementById("overlay_container").style.display = "none"
        }

        document.getElementById("next_scene").focus()
    }

    function init() {
        onNextAnimation()
        animate()
        const changeSize = () => {
            const canvas = document.getElementById("canvas")
            const rect = canvas.getBoundingClientRect()
            const overlay = document.getElementById("overlay_container")
            const scale = rect.width / WIDTH
            overlay.style.left = rect.left + leftScreen.w * scale
            overlay.style.width = rect.right - rightScreen.w * scale - (rect.left + leftScreen.w * scale)
            overlay.style.top = rect.top
            overlay.style.height = rect.bottom - rect.top
        }
        new ResizeObserver(changeSize).observe(document.getElementById("canvas"))
        changeSize()
    }

</script>
<canvas id="canvas" style="width: 100%; height: auto; position: relative">
</canvas>
<div id="overlay_container" style="position: absolute; display: flex; align-items: center; justify-content: center;">
    <div id="overlay"></div>
</div>
<button id="next_scene" autofocus onclick="onNextScene()">Next scene</button>
<button id="next_animation" onclick="onNextAnimation()">Next</button>
</body>
</html>